/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/ui/customPromptModal.ts
var customPromptModal_exports = {};
__export(customPromptModal_exports, {
  CustomPromptModal: () => CustomPromptModal
});
var import_obsidian8, CustomPromptModal;
var init_customPromptModal = __esm({
  "src/ui/customPromptModal.ts"() {
    import_obsidian8 = require("obsidian");
    CustomPromptModal = class extends import_obsidian8.Modal {
      constructor(app, defaultPrompt, onSubmit) {
        super(app);
        this.prompt = defaultPrompt;
        this.onSubmit = onSubmit;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("stt-prompt-modal");
        contentEl.createEl("h2", { text: "Custom Prompt" });
        contentEl.createEl("p", {
          text: "Enter your prompt. The selected text will be appended.",
          cls: "setting-item-description"
        });
        const textArea = contentEl.createEl("textarea");
        textArea.value = this.prompt;
        textArea.placeholder = "Enter your prompt here...";
        textArea.rows = 6;
        textArea.addEventListener("input", (e) => {
          this.prompt = e.target.value;
        });
        setTimeout(() => textArea.focus(), 10);
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
        const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
        cancelBtn.addEventListener("click", () => {
          this.onSubmit(null);
          this.close();
        });
        const submitBtn = buttonContainer.createEl("button", {
          text: "Send",
          cls: "mod-cta"
        });
        submitBtn.addEventListener("click", () => {
          this.onSubmit(this.prompt);
          this.close();
        });
        textArea.addEventListener("keydown", (e) => {
          if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            this.onSubmit(this.prompt);
            this.close();
          }
          if (e.key === "Escape") {
            e.preventDefault();
            this.onSubmit(null);
            this.close();
          }
        });
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SttLlmPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian9 = require("obsidian");

// src/settings.ts
var LANGUAGE_OPTIONS = [
  { code: "en", name: "English" },
  { code: "es", name: "Spanish" },
  { code: "fr", name: "French" },
  { code: "de", name: "German" },
  { code: "it", name: "Italian" },
  { code: "pt", name: "Portuguese" },
  { code: "ru", name: "Russian" },
  { code: "zh", name: "Chinese" },
  { code: "ja", name: "Japanese" },
  { code: "ko", name: "Korean" },
  { code: "ar", name: "Arabic" },
  { code: "hi", name: "Hindi" },
  { code: "nl", name: "Dutch" },
  { code: "pl", name: "Polish" },
  { code: "tr", name: "Turkish" },
  { code: "vi", name: "Vietnamese" },
  { code: "th", name: "Thai" },
  { code: "id", name: "Indonesian" },
  { code: "uk", name: "Ukrainian" },
  { code: "cs", name: "Czech" },
  { code: "auto", name: "Auto-detect" }
];
var DEFAULT_VOICE_COMMANDS = [
  // Paired formatting commands
  {
    type: "bold",
    startTrigger: "start bold",
    endTrigger: "end bold",
    markdownStart: "**",
    markdownEnd: "**",
    isPaired: true
  },
  {
    type: "italic",
    startTrigger: "start italic",
    endTrigger: "end italic",
    markdownStart: "*",
    markdownEnd: "*",
    isPaired: true
  },
  {
    type: "strikethrough",
    startTrigger: "start strikethrough",
    endTrigger: "end strikethrough",
    markdownStart: "~~",
    markdownEnd: "~~",
    isPaired: true
  },
  {
    type: "code_inline",
    startTrigger: "start code",
    endTrigger: "end code",
    markdownStart: "`",
    markdownEnd: "`",
    isPaired: true
  },
  {
    type: "code_block",
    startTrigger: "start code block",
    endTrigger: "end code block",
    markdownStart: "\n```\n",
    markdownEnd: "\n```\n",
    isPaired: true
  },
  {
    type: "blockquote",
    startTrigger: "start quote",
    endTrigger: "end quote",
    markdownStart: "\n> ",
    markdownEnd: "\n",
    isPaired: true
  },
  {
    type: "link",
    startTrigger: "start link",
    endTrigger: "end link",
    markdownStart: "[",
    markdownEnd: "](url)",
    isPaired: true
  },
  // Single-action commands - headings
  {
    type: "heading_1",
    startTrigger: "heading one",
    markdownStart: "\n# ",
    isPaired: false
  },
  {
    type: "heading_2",
    startTrigger: "heading two",
    markdownStart: "\n## ",
    isPaired: false
  },
  {
    type: "heading_3",
    startTrigger: "heading three",
    markdownStart: "\n### ",
    isPaired: false
  },
  {
    type: "heading_4",
    startTrigger: "heading four",
    markdownStart: "\n#### ",
    isPaired: false
  },
  {
    type: "heading_5",
    startTrigger: "heading five",
    markdownStart: "\n##### ",
    isPaired: false
  },
  {
    type: "heading_6",
    startTrigger: "heading six",
    markdownStart: "\n###### ",
    isPaired: false
  },
  // Single-action commands - lists
  {
    type: "bullet_list",
    startTrigger: "bullet point",
    markdownStart: "\n- ",
    isPaired: false
  },
  {
    type: "numbered_list",
    startTrigger: "numbered item",
    markdownStart: "\n1. ",
    isPaired: false
  },
  {
    type: "checkbox",
    startTrigger: "checkbox",
    markdownStart: "\n- [ ] ",
    isPaired: false
  },
  // Single-action commands - whitespace
  {
    type: "new_line",
    startTrigger: "new line",
    markdownStart: "\n",
    isPaired: false
  },
  {
    type: "new_paragraph",
    startTrigger: "new paragraph",
    markdownStart: "\n\n",
    isPaired: false
  }
];
var DEFAULT_SETTINGS = {
  stt: {
    serverUrl: "ws://localhost:8765",
    language: "en"
  },
  vad: {
    enabled: true,
    silenceThreshold: 15,
    // 0-100 scale
    silenceDuration: 1.5
    // seconds
  },
  correction: {
    enabled: false,
    prompt: `Fix any transcription errors in the following text. Correct grammar, punctuation, and obvious word mistakes. Keep the original meaning and style. Only output the corrected text, nothing else.

Text: {{text}}`
  },
  llm: {
    baseUrl: "http://localhost:11434",
    apiKey: "",
    model: "llama3.2",
    temperature: 0.7,
    maxTokens: 2048
  },
  summarization: {
    prompt: `Provide a single, concise summary of the following text. Focus on the key points and main ideas. Output ONLY the summary paragraph(s) - no headers, labels, or multiple versions.

Text:
{{text}}`
  },
  tagging: {
    preferExistingTags: true,
    maxNewTags: 5,
    prompt: `Analyze the following content and suggest relevant tags for organizing this note.

{{#if existingTags}}
Prefer tags from this existing list when appropriate: {{existingTags}}
You may also suggest new tags if none of the existing ones fit well.
{{/if}}

Content:
{{content}}

Return ONLY a JSON array of tag strings (without # prefix), e.g., ["tag1", "tag2"]. No other text.`
  },
  customPrompt: {
    defaultPrompt: ""
  },
  voiceCommands: {
    enabled: true,
    commands: DEFAULT_VOICE_COMMANDS
  }
};
function isLlmConfigured(settings) {
  return !!(settings.llm.baseUrl && settings.llm.model);
}

// src/settingsTab.ts
var import_obsidian = require("obsidian");
var SttLlmSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Speech-to-text").setHeading();
    new import_obsidian.Setting(containerEl).setName("STT Server URL").setDesc("WebSocket URL for the transcription server").addText(
      (text) => text.setPlaceholder("ws://localhost:8765").setValue(this.plugin.settings.stt.serverUrl).onChange(async (value) => {
        this.plugin.settings.stt.serverUrl = value;
        await this.plugin.saveSettings();
      })
    ).addButton(
      (button) => button.setButtonText("Test Connection").onClick(async () => {
        const url = this.plugin.settings.stt.serverUrl;
        new import_obsidian.Notice("Testing connection...");
        try {
          const ws = new WebSocket(url);
          await new Promise((resolve, reject) => {
            ws.onopen = () => {
              new import_obsidian.Notice("Connection successful!");
              ws.close();
              resolve();
            };
            ws.onerror = () => {
              reject(new Error("Connection failed"));
            };
            setTimeout(() => reject(new Error("Connection timeout")), 5e3);
          });
        } catch (error) {
          new import_obsidian.Notice(`Connection failed: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("Language").setDesc("Language for transcription").addDropdown((dropdown) => {
      for (const lang of LANGUAGE_OPTIONS) {
        dropdown.addOption(lang.code, `${lang.name} (${lang.code})`);
      }
      dropdown.setValue(this.plugin.settings.stt.language);
      dropdown.onChange(async (value) => {
        this.plugin.settings.stt.language = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Auto-stop on silence").setDesc("Stop recording automatically when you stop speaking").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.vad.enabled).onChange(async (value) => {
        this.plugin.settings.vad.enabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Silence duration").setDesc("Seconds of silence before auto-stop").addSlider(
      (slider) => slider.setLimits(0.5, 5, 0.5).setValue(this.plugin.settings.vad.silenceDuration).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.vad.silenceDuration = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("LLM (optional)").setHeading();
    const llmConfigured = isLlmConfigured(this.plugin.settings);
    const llmStatusEl = containerEl.createEl("div", {
      cls: "stt-llm-status"
    });
    if (llmConfigured) {
      llmStatusEl.createEl("span", {
        text: "LLM features are enabled",
        cls: "stt-llm-status-enabled"
      });
    } else {
      llmStatusEl.createEl("span", {
        text: "Configure LLM to enable summarization, tagging, and custom prompts",
        cls: "stt-llm-status-disabled"
      });
    }
    new import_obsidian.Setting(containerEl).setName("API Base URL").setDesc("OpenAI-compatible API endpoint (Ollama, LM Studio, etc.)").addText(
      (text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.llm.baseUrl).onChange(async (value) => {
        this.plugin.settings.llm.baseUrl = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Model").setDesc("Model name for completions").addText(
      (text) => text.setPlaceholder("llama3.2").setValue(this.plugin.settings.llm.model).onChange(async (value) => {
        this.plugin.settings.llm.model = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("Optional API key (leave empty for local servers)").addText(
      (text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.llm.apiKey).onChange(async (value) => {
        this.plugin.settings.llm.apiKey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto-tagging").setHeading();
    new import_obsidian.Setting(containerEl).setName("Prefer existing tags").setDesc("Prioritize tags already used in your vault").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.tagging.preferExistingTags).onChange(async (value) => {
        this.plugin.settings.tagging.preferExistingTags = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Max new tags").setDesc("Maximum tags to generate per note").addSlider(
      (slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.tagging.maxNewTags).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.tagging.maxNewTags = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Voice commands").setHeading();
    new import_obsidian.Setting(containerEl).setName("Enable voice commands").setDesc("Convert spoken commands to Markdown formatting (e.g., 'start bold' \u2192 **)").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.voiceCommands.enabled).onChange(async (value) => {
        this.plugin.settings.voiceCommands.enabled = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.voiceCommands.enabled) {
      const commandsContainer = containerEl.createEl("div", {
        cls: "stt-voice-commands-container"
      });
      const pairedCommands = this.plugin.settings.voiceCommands.commands.filter(
        (c) => c.isPaired
      );
      const singleCommands = this.plugin.settings.voiceCommands.commands.filter(
        (c) => !c.isPaired
      );
      new import_obsidian.Setting(commandsContainer).setName("Paired commands (start/end)").setHeading();
      for (const command of pairedCommands) {
        this.renderCommandSetting(commandsContainer, command);
      }
      new import_obsidian.Setting(commandsContainer).setName("Single commands").setHeading();
      for (const command of singleCommands) {
        this.renderCommandSetting(commandsContainer, command);
      }
      new import_obsidian.Setting(containerEl).setName("Reset to defaults").setDesc("Restore all voice commands to their default trigger phrases").addButton(
        (button) => button.setButtonText("Reset").onClick(async () => {
          this.plugin.settings.voiceCommands.commands = JSON.parse(
            JSON.stringify(DEFAULT_VOICE_COMMANDS)
          );
          await this.plugin.saveSettings();
          this.display();
          new import_obsidian.Notice("Voice commands reset to defaults");
        })
      );
    }
    const advancedDetails = containerEl.createEl("details", { cls: "stt-llm-advanced-settings" });
    advancedDetails.createEl("summary", { text: "Advanced Settings" });
    const advancedContainer = advancedDetails.createEl("div", { cls: "stt-llm-advanced-content" });
    new import_obsidian.Setting(advancedContainer).setName("LLM parameters").setHeading();
    new import_obsidian.Setting(advancedContainer).setName("Temperature").setDesc("Controls randomness (0 = deterministic, 1 = creative)").addSlider(
      (slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.llm.temperature).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.llm.temperature = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(advancedContainer).setName("Max tokens").setDesc("Maximum tokens in response").addText(
      (text) => text.setPlaceholder("2048").setValue(String(this.plugin.settings.llm.maxTokens)).onChange(async (value) => {
        const parsed = parseInt(value, 10);
        if (!isNaN(parsed) && parsed > 0) {
          this.plugin.settings.llm.maxTokens = parsed;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian.Setting(advancedContainer).setName("Voice detection").setHeading();
    new import_obsidian.Setting(advancedContainer).setName("Silence threshold").setDesc("Audio level below this is considered silence (0-100)").addSlider(
      (slider) => slider.setLimits(5, 50, 5).setValue(this.plugin.settings.vad.silenceThreshold).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.vad.silenceThreshold = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(advancedContainer).setName("Prompt templates").setHeading();
    new import_obsidian.Setting(advancedContainer).setName("LLM correction").setDesc("Use LLM to fix transcription errors (shows both original and corrected)").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.correction.enabled).onChange(async (value) => {
        this.plugin.settings.correction.enabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(advancedContainer).setName("Correction prompt").setDesc("Use {{text}} for the transcription").addTextArea(
      (text) => text.setPlaceholder("Fix transcription errors...").setValue(this.plugin.settings.correction.prompt).onChange(async (value) => {
        this.plugin.settings.correction.prompt = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(advancedContainer).setName("Summarization prompt").setDesc("Use {{text}} for selected text").addTextArea(
      (text) => text.setPlaceholder("Summarize the following...").setValue(this.plugin.settings.summarization.prompt).onChange(async (value) => {
        this.plugin.settings.summarization.prompt = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(advancedContainer).setName("Tagging prompt").setDesc("Use {{content}} and {{existingTags}}").addTextArea(
      (text) => text.setPlaceholder("Analyze and suggest tags...").setValue(this.plugin.settings.tagging.prompt).onChange(async (value) => {
        this.plugin.settings.tagging.prompt = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(advancedContainer).setName("Default custom prompt").setDesc("Pre-fill text for custom prompt modal").addTextArea(
      (text) => text.setPlaceholder("Enter default prompt...").setValue(this.plugin.settings.customPrompt.defaultPrompt).onChange(async (value) => {
        this.plugin.settings.customPrompt.defaultPrompt = value;
        await this.plugin.saveSettings();
      })
    );
  }
  /**
   * Render a single voice command setting
   */
  renderCommandSetting(container, command) {
    const commandEl = container.createEl("div", { cls: "stt-voice-command-item" });
    const typeLabel = this.formatCommandType(command.type);
    const preview = command.isPaired ? `${command.markdownStart}text${command.markdownEnd}` : command.markdownStart.replace(/\n/g, "\u21B5");
    const headerEl = commandEl.createEl("div", { cls: "stt-voice-command-header" });
    headerEl.createEl("span", { text: typeLabel, cls: "stt-voice-command-type" });
    headerEl.createEl("code", { text: preview, cls: "stt-voice-command-preview" });
    new import_obsidian.Setting(commandEl).setName(command.isPaired ? "Start trigger" : "Trigger phrase").addText(
      (text) => text.setValue(command.startTrigger).onChange(async (value) => {
        command.startTrigger = value;
        await this.plugin.saveSettings();
      })
    );
    if (command.isPaired && command.endTrigger !== void 0) {
      new import_obsidian.Setting(commandEl).setName("End trigger").addText(
        (text) => text.setValue(command.endTrigger || "").onChange(async (value) => {
          command.endTrigger = value;
          await this.plugin.saveSettings();
        })
      );
    }
  }
  /**
   * Format a command type for display
   */
  formatCommandType(type) {
    const typeLabels = {
      bold: "Bold",
      italic: "Italic",
      strikethrough: "Strikethrough",
      code_inline: "Inline Code",
      code_block: "Code Block",
      blockquote: "Blockquote",
      heading_1: "Heading 1",
      heading_2: "Heading 2",
      heading_3: "Heading 3",
      heading_4: "Heading 4",
      heading_5: "Heading 5",
      heading_6: "Heading 6",
      bullet_list: "Bullet List",
      numbered_list: "Numbered List",
      checkbox: "Checkbox",
      link: "Link",
      new_line: "New Line",
      new_paragraph: "New Paragraph"
    };
    return typeLabels[type] || type;
  }
};

// src/services/llmService.ts
var import_obsidian2 = require("obsidian");
var LlmService = class {
  constructor(getSettings) {
    this.getSettings = getSettings;
  }
  async complete(userPrompt, systemPrompt) {
    const settings = this.getSettings();
    const messages = [];
    if (systemPrompt) {
      messages.push({ role: "system", content: systemPrompt });
    }
    messages.push({ role: "user", content: userPrompt });
    const isOllama = settings.baseUrl.includes("11434");
    const endpoint = isOllama ? `${settings.baseUrl}/v1/chat/completions` : `${settings.baseUrl}/v1/chat/completions`;
    const headers = {
      "Content-Type": "application/json"
    };
    if (settings.apiKey) {
      headers["Authorization"] = `Bearer ${settings.apiKey}`;
    }
    const body = {
      model: settings.model,
      messages,
      temperature: settings.temperature,
      max_tokens: settings.maxTokens
    };
    try {
      const response = await (0, import_obsidian2.requestUrl)({
        url: endpoint,
        method: "POST",
        headers,
        body: JSON.stringify(body),
        throw: false
      });
      if (response.status !== 200) {
        const errorText = response.text || `HTTP ${response.status}`;
        throw new Error(`LLM request failed: ${errorText}`);
      }
      const data = response.json;
      if (!data.choices || data.choices.length === 0) {
        throw new Error("No response from LLM");
      }
      return data.choices[0].message.content;
    } catch (error) {
      if (error instanceof Error) {
        if (error.message.includes("ECONNREFUSED")) {
          throw new Error(
            `Cannot connect to LLM server at ${settings.baseUrl}. Is the server running?`
          );
        }
        throw error;
      }
      throw new Error("Unknown error occurred");
    }
  }
  async correctTranscription(rawText, correctionPrompt) {
    const prompt = correctionPrompt.replace("{{text}}", rawText);
    return this.complete(prompt);
  }
};

// src/services/tagService.ts
var import_obsidian3 = require("obsidian");
var TagService = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Get all unique tags used across the vault
   */
  getAllVaultTags() {
    const tagSet = /* @__PURE__ */ new Set();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (cache) {
        const tags = (0, import_obsidian3.getAllTags)(cache);
        if (tags) {
          for (const tag of tags) {
            tagSet.add(tag.startsWith("#") ? tag.slice(1) : tag);
          }
        }
      }
    }
    return Array.from(tagSet).sort();
  }
  /**
   * Get tags that match a partial string (for autocomplete)
   */
  searchTags(query) {
    const allTags = this.getAllVaultTags();
    const lowerQuery = query.toLowerCase();
    return allTags.filter((tag) => tag.toLowerCase().includes(lowerQuery));
  }
  /**
   * Get the most commonly used tags
   */
  getPopularTags(limit = 20) {
    const tagCounts = /* @__PURE__ */ new Map();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (cache) {
        const tags = (0, import_obsidian3.getAllTags)(cache);
        if (tags) {
          for (const tag of tags) {
            const normalizedTag = tag.startsWith("#") ? tag.slice(1) : tag;
            tagCounts.set(normalizedTag, (tagCounts.get(normalizedTag) || 0) + 1);
          }
        }
      }
    }
    return Array.from(tagCounts.entries()).sort((a, b) => b[1] - a[1]).slice(0, limit).map(([tag]) => tag);
  }
};

// src/services/sttService.ts
var SttService = class {
  constructor(url) {
    this.ws = null;
    this.listeners = {};
    this._status = "disconnected";
    this.connectionId = 0;
    this.url = url;
  }
  get status() {
    return this._status;
  }
  get isConnected() {
    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;
  }
  get isRecording() {
    return this._status === "recording";
  }
  setUrl(url) {
    this.url = url;
  }
  on(event, callback) {
    this.listeners[event] = callback;
  }
  off(event) {
    delete this.listeners[event];
  }
  emit(event, ...args) {
    const callback = this.listeners[event];
    if (callback) {
      callback(...args);
    }
  }
  setStatus(status, error) {
    this._status = status;
    this.emit("status", { status, error });
  }
  async connect() {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      return;
    }
    if (this.ws) {
      this.ws.onclose = null;
      this.ws.onerror = null;
      this.ws.onmessage = null;
      this.ws.onopen = null;
      try {
        this.ws.close();
      } catch (e) {
      }
      this.ws = null;
    }
    this.setStatus("connecting");
    this.connectionId++;
    const thisConnectionId = this.connectionId;
    return new Promise((resolve, reject) => {
      let resolved = false;
      let timeoutId = null;
      const cleanup = () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
      };
      try {
        const ws = new WebSocket(this.url);
        timeoutId = setTimeout(() => {
          if (!resolved && thisConnectionId === this.connectionId) {
            resolved = true;
            ws.close();
            if (this.ws === ws)
              this.ws = null;
            reject(new Error("Connection timeout"));
          }
        }, 1e4);
        ws.onopen = () => {
          if (thisConnectionId !== this.connectionId) {
            ws.close();
            return;
          }
          if (!resolved) {
            resolved = true;
            cleanup();
            this.ws = ws;
            this.emit("connected");
            resolve();
          }
        };
        ws.onclose = (event) => {
          cleanup();
          if (thisConnectionId !== this.connectionId) {
            return;
          }
          if (this.ws === ws)
            this.ws = null;
          this.setStatus("disconnected");
          this.emit("disconnected");
          if (!resolved) {
            resolved = true;
            reject(new Error("Connection closed"));
          }
        };
        ws.onerror = (error) => {
          cleanup();
          if (thisConnectionId !== this.connectionId) {
            return;
          }
          if (!resolved) {
            resolved = true;
            this.setStatus("error", "Connection error");
            reject(new Error("WebSocket connection failed"));
          }
        };
        ws.onmessage = (event) => {
          if (thisConnectionId !== this.connectionId) {
            return;
          }
          this.handleMessage(event.data);
        };
      } catch (error) {
        cleanup();
        this.setStatus("error", "Failed to create WebSocket");
        reject(error);
      }
    });
  }
  disconnect() {
    this.connectionId++;
    if (this.ws) {
      this.ws.onclose = null;
      this.ws.onerror = null;
      this.ws.onmessage = null;
      this.ws.onopen = null;
      try {
        this.ws.close(1e3, "Client disconnect");
      } catch (e) {
      }
      this.ws = null;
    }
    this.setStatus("disconnected");
  }
  startRecording(language) {
    var _a;
    if (!this.isConnected) {
      throw new Error("Not connected to STT server");
    }
    const message = { type: "start" };
    if (language) {
      message.language = language;
    }
    (_a = this.ws) == null ? void 0 : _a.send(JSON.stringify(message));
  }
  stopRecording() {
    var _a;
    if (!this.isConnected) {
      throw new Error("Not connected to STT server");
    }
    (_a = this.ws) == null ? void 0 : _a.send(JSON.stringify({ type: "stop" }));
  }
  sendAudioChunk(audioData) {
    var _a;
    if (!this.isConnected || this._status !== "recording") {
      return;
    }
    const base64 = this.arrayBufferToBase64(audioData);
    (_a = this.ws) == null ? void 0 : _a.send(
      JSON.stringify({
        type: "audio",
        data: base64
      })
    );
  }
  arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = "";
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }
  handleMessage(data) {
    try {
      const message = JSON.parse(data);
      switch (message.type) {
        case "status":
          this.setStatus(message.status, message.error);
          break;
        case "transcript":
          this.emit("transcript", {
            text: message.text,
            isFinal: message.isFinal
          });
          break;
        default:
      }
    } catch (error) {
    }
  }
};

// src/features/recordingManager.ts
var import_obsidian5 = require("obsidian");

// src/services/voiceCommandProcessor.ts
var VoiceCommandProcessor = class {
  constructor(getSettings) {
    this.getSettings = getSettings;
  }
  /**
   * Main entry point - process raw transcript and return formatted text
   */
  process(rawText) {
    const settings = this.getSettings();
    if (!settings.enabled) {
      return { processedText: rawText, warnings: [] };
    }
    const warnings = [];
    let text = rawText;
    const triggerMap = this.buildTriggerMap(settings.commands);
    const occurrences = this.findAllOccurrences(text, triggerMap);
    if (occurrences.length === 0) {
      return { processedText: text, warnings: [] };
    }
    const markers = occurrences.map((occ) => ({
      index: occ.index,
      length: occ.matchedText.length,
      replacement: occ.isStartTrigger ? occ.command.markdownStart : occ.command.markdownEnd || "",
      isStart: occ.isStartTrigger,
      command: occ.command
    }));
    const validationWarnings = this.validatePairing(markers);
    warnings.push(...validationWarnings);
    markers.sort((a, b) => b.index - a.index);
    for (const marker of markers) {
      text = text.substring(0, marker.index) + marker.replacement + text.substring(marker.index + marker.length);
    }
    text = this.cleanupWhitespace(text);
    return { processedText: text, warnings };
  }
  /**
   * Build a map of normalized trigger phrases to commands
   */
  buildTriggerMap(commands) {
    const map = /* @__PURE__ */ new Map();
    for (const cmd of commands) {
      const normalizedStart = this.normalizeTrigger(cmd.startTrigger);
      map.set(normalizedStart, { command: cmd, isStart: true });
      if (cmd.endTrigger) {
        const normalizedEnd = this.normalizeTrigger(cmd.endTrigger);
        map.set(normalizedEnd, { command: cmd, isStart: false });
      }
    }
    return map;
  }
  /**
   * Normalize a trigger phrase for matching:
   * - Lowercase
   * - Remove punctuation
   * - Collapse whitespace
   */
  normalizeTrigger(trigger) {
    return trigger.toLowerCase().replace(/[.,!?;:'"]/g, "").replace(/\s+/g, " ").trim();
  }
  /**
   * Build a regex pattern that tolerates punctuation and whitespace variations
   * @param trigger - The trigger phrase to match
   * @param captureTrailingSpace - If true, capture trailing whitespace (for start triggers)
   * @param captureLeadingSpace - If true, capture leading whitespace (for end triggers)
   */
  buildFlexiblePattern(trigger, captureTrailingSpace, captureLeadingSpace) {
    const words = trigger.split(" ");
    let pattern = words.map((word) => word.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")).map((word) => word + `[.,!?;:'"]*`).join("\\s+");
    if (captureLeadingSpace) {
      pattern = "\\s*" + pattern;
    }
    if (captureTrailingSpace) {
      pattern = pattern + "\\s*";
    }
    return pattern;
  }
  /**
   * Find all command occurrences in the text
   */
  findAllOccurrences(text, triggerMap) {
    const results = [];
    const triggers = Array.from(triggerMap.keys()).sort(
      (a, b) => b.length - a.length
    );
    const claimedRanges = [];
    for (const trigger of triggers) {
      const { command, isStart } = triggerMap.get(trigger);
      const isPaired = command.isPaired;
      const captureTrailing = isPaired && isStart;
      const captureLeading = isPaired && !isStart;
      const regexPattern = this.buildFlexiblePattern(
        trigger,
        captureTrailing,
        captureLeading
      );
      const regex = new RegExp(regexPattern, "gi");
      let match;
      while ((match = regex.exec(text)) !== null) {
        const matchStart = match.index;
        const matchEnd = match.index + match[0].length;
        const overlaps = claimedRanges.some(
          (range) => matchStart < range.end && matchEnd > range.start
        );
        if (!overlaps) {
          results.push({
            command,
            isStartTrigger: isStart,
            index: match.index,
            matchedText: match[0]
          });
          claimedRanges.push({ start: matchStart, end: matchEnd });
        }
      }
    }
    return results;
  }
  /**
   * Validate that paired commands are properly nested
   */
  validatePairing(markers) {
    const warnings = [];
    const stack = [];
    const sorted = [...markers].sort((a, b) => a.index - b.index);
    for (const marker of sorted) {
      if (!marker.command.isPaired)
        continue;
      if (marker.isStart) {
        stack.push({ command: marker.command, index: marker.index });
      } else {
        const lastOpen = stack.pop();
        if (!lastOpen) {
          warnings.push(
            `Unmatched "${marker.command.endTrigger}" found`
          );
        } else if (lastOpen.command.type !== marker.command.type) {
          warnings.push(
            `Mismatched nesting: "${lastOpen.command.startTrigger}" closed by "${marker.command.endTrigger}"`
          );
          stack.push(lastOpen);
        }
      }
    }
    for (const open of stack) {
      warnings.push(`Unclosed "${open.command.startTrigger}"`);
    }
    return warnings;
  }
  /**
   * Clean up whitespace artifacts from command replacement
   */
  cleanupWhitespace(text) {
    return text.replace(/\n{3,}/g, "\n\n").replace(/  +/g, " ").trim();
  }
};

// src/ui/recordingModal.ts
var import_obsidian4 = require("obsidian");
var RecordingModal = class extends import_obsidian4.Modal {
  constructor(app, onStop) {
    super(app);
    this.audioLevelEl = null;
    this.audioLevelBar = null;
    this.currentTranscript = "";
    this.onStop = onStop;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("stt-recording-modal");
    this.statusEl = contentEl.createEl("div", {
      cls: "stt-status",
      text: "Connecting..."
    });
    this.indicatorEl = contentEl.createEl("div", { cls: "stt-indicator stt-hidden" });
    this.indicatorEl.createEl("span", { cls: "stt-pulse" });
    this.audioLevelEl = contentEl.createEl("div", { cls: "stt-audio-level stt-hidden" });
    this.audioLevelBar = this.audioLevelEl.createEl("div", { cls: "stt-audio-level-bar" });
    this.transcriptEl = contentEl.createEl("div", {
      cls: "stt-transcript",
      text: "Waiting for speech..."
    });
    this.stopBtn = contentEl.createEl("button", {
      text: "Stop Recording",
      cls: "stt-stop-btn mod-cta"
    });
    this.stopBtn.addEventListener("click", () => {
      this.onStop();
    });
    this.scope.register([], "Escape", () => {
      this.onStop();
      return false;
    });
  }
  /**
   * Update the status display
   */
  updateStatus(status) {
    if (this.statusEl) {
      this.statusEl.setText(status);
    }
    const isRecording = status.toLowerCase().includes("recording");
    if (this.indicatorEl) {
      this.indicatorEl.toggleClass("stt-hidden", !isRecording);
    }
    if (this.audioLevelEl) {
      this.audioLevelEl.toggleClass("stt-hidden", !isRecording);
    }
  }
  /**
   * Update the audio level display (0-100) and optional silence countdown
   */
  updateAudioLevel(level, silenceCountdown) {
    if (this.audioLevelBar) {
      this.audioLevelBar.style.width = `${Math.min(100, level)}%`;
    }
    if (this.statusEl) {
      if (silenceCountdown !== void 0 && silenceCountdown > 0) {
        this.statusEl.setText(`Recording... (auto-stop in ${silenceCountdown.toFixed(1)}s)`);
      } else if (this.statusEl.getText().includes("auto-stop")) {
        this.statusEl.setText("Recording... Speak now");
      }
    }
  }
  /**
   * Update the transcript display
   */
  updateTranscript(text, isFinal) {
    this.currentTranscript = text;
    if (this.transcriptEl) {
      if (text) {
        this.transcriptEl.setText(text);
        this.transcriptEl.removeClass("stt-final");
        if (isFinal) {
          this.transcriptEl.addClass("stt-final");
        }
      } else {
        this.transcriptEl.setText("Waiting for speech...");
      }
    }
  }
  /**
   * Get the current transcript
   */
  getTranscript() {
    return this.currentTranscript;
  }
  /**
   * Show error state
   */
  showError(message) {
    this.updateStatus(`Error: ${message}`);
    if (this.indicatorEl) {
      this.indicatorEl.addClass("stt-hidden");
    }
    if (this.stopBtn) {
      this.stopBtn.setText("Close");
    }
  }
  /**
   * Show processing state
   */
  showProcessing() {
    this.updateStatus("Processing final transcript...");
    if (this.indicatorEl) {
      this.indicatorEl.addClass("stt-hidden");
    }
    if (this.stopBtn) {
      this.stopBtn.disabled = true;
      this.stopBtn.setText("Processing...");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/features/recordingManager.ts
var RecordingManager = class {
  constructor(app, sttService, llmService, getSettings) {
    this.state = "idle";
    this.modal = null;
    this.mediaRecorder = null;
    this.mediaStream = null;
    this.audioChunks = [];
    this.finalTranscript = "";
    this.ribbonIcon = null;
    // VAD (Voice Activity Detection)
    this.audioContext = null;
    this.analyser = null;
    this.vadInterval = null;
    this.silenceStart = null;
    this.app = app;
    this.sttService = sttService;
    this.llmService = llmService;
    this.getSettings = getSettings;
    this.voiceCommandProcessor = new VoiceCommandProcessor(
      () => getSettings().voiceCommands
    );
    this.setupSttCallbacks();
  }
  setRibbonIcon(icon) {
    this.ribbonIcon = icon;
  }
  isRecording() {
    return this.state === "recording";
  }
  setupSttCallbacks() {
    this.sttService.on("status", ({ status, error }) => {
      var _a, _b, _c;
      if (status === "recording") {
        this.state = "recording";
        (_a = this.modal) == null ? void 0 : _a.updateStatus("Recording... Speak now");
        this.updateRibbonState(true);
        this.startVAD();
      } else if (status === "processing") {
        this.state = "processing";
        (_b = this.modal) == null ? void 0 : _b.showProcessing();
      } else if (status === "ready") {
        if (this.state === "processing") {
          this.handleRecordingComplete();
        }
      } else if (status === "error") {
        (_c = this.modal) == null ? void 0 : _c.showError(error || "Unknown error");
        this.cleanup();
      }
    });
    this.sttService.on("transcript", ({ text, isFinal }) => {
      var _a;
      (_a = this.modal) == null ? void 0 : _a.updateTranscript(text, isFinal);
      if (isFinal) {
        this.finalTranscript = text;
      }
    });
    this.sttService.on("disconnected", () => {
      if (this.state !== "idle") {
        new import_obsidian5.Notice("STT server disconnected");
        this.cleanup();
      }
    });
  }
  async toggleRecording() {
    if (this.state === "idle") {
      await this.startRecording();
    } else if (this.state === "recording") {
      await this.stopRecording();
    }
  }
  async startRecording() {
    var _a;
    if (this.state !== "idle") {
      return;
    }
    const settings = this.getSettings();
    this.sttService.setUrl(settings.stt.serverUrl);
    this.modal = new RecordingModal(this.app, () => this.stopRecording());
    this.modal.open();
    this.modal.updateStatus("Connecting to STT server...");
    this.state = "connecting";
    try {
      await this.sttService.connect();
      await this.startAudioCapture();
      this.sttService.startRecording(settings.stt.language);
      this.finalTranscript = "";
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      (_a = this.modal) == null ? void 0 : _a.showError(message);
      new import_obsidian5.Notice(`Failed to start recording: ${message}`);
      this.cleanup();
    }
  }
  async stopRecording() {
    var _a;
    if (this.state !== "recording") {
      if (this.state === "connecting" || this.state === "processing") {
        this.cleanup();
      }
      return;
    }
    this.state = "processing";
    (_a = this.modal) == null ? void 0 : _a.showProcessing();
    this.stopVAD();
    try {
      await this.stopAudioCapture();
      this.sttService.stopRecording();
    } catch (error) {
      this.cleanup();
    }
  }
  startVAD() {
    const settings = this.getSettings();
    if (!settings.vad.enabled || !this.mediaStream) {
      return;
    }
    try {
      this.audioContext = new AudioContext();
      const source = this.audioContext.createMediaStreamSource(this.mediaStream);
      this.analyser = this.audioContext.createAnalyser();
      this.analyser.fftSize = 256;
      source.connect(this.analyser);
      const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
      this.silenceStart = null;
      this.vadInterval = setInterval(() => {
        var _a, _b;
        if (!this.analyser || this.state !== "recording") {
          return;
        }
        this.analyser.getByteFrequencyData(dataArray);
        const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
        const level = average / 255 * 100;
        const threshold = settings.vad.silenceThreshold;
        const silenceDurationMs = settings.vad.silenceDuration * 1e3;
        let countdown;
        if (level < threshold) {
          if (this.silenceStart === null) {
            this.silenceStart = Date.now();
          }
          const elapsed = Date.now() - this.silenceStart;
          const remaining = (silenceDurationMs - elapsed) / 1e3;
          countdown = Math.max(0, remaining);
          if (elapsed > silenceDurationMs) {
            this.stopRecording();
            return;
          }
        } else {
          this.silenceStart = null;
        }
        (_b = (_a = this.modal) == null ? void 0 : _a.updateAudioLevel) == null ? void 0 : _b.call(_a, level, countdown);
      }, 100);
    } catch (error) {
    }
  }
  stopVAD() {
    if (this.vadInterval) {
      clearInterval(this.vadInterval);
      this.vadInterval = null;
    }
    if (this.audioContext) {
      this.audioContext.close().catch(() => {
      });
      this.audioContext = null;
    }
    this.analyser = null;
    this.silenceStart = null;
  }
  async handleRecordingComplete() {
    var _a, _b;
    const originalText = this.finalTranscript || ((_a = this.modal) == null ? void 0 : _a.getTranscript()) || "";
    if (!originalText.trim()) {
      new import_obsidian5.Notice("No speech detected");
      this.cleanup();
      return;
    }
    const { processedText, warnings } = this.voiceCommandProcessor.process(originalText);
    const settings = this.getSettings();
    if (settings.correction.enabled) {
      try {
        (_b = this.modal) == null ? void 0 : _b.updateStatus("Applying LLM correction...");
        const correctedText = await this.llmService.correctTranscription(
          processedText,
          // Use processed text (commands already converted)
          settings.correction.prompt
        );
        const combined = `${correctedText}

> [!info] LLM Correction Applied
> **Original transcript:**
> ${originalText.split("\n").join("\n> ")}`;
        this.insertAtCursor(combined);
      } catch (error) {
        this.insertAtCursor(processedText);
      }
    } else {
      this.insertAtCursor(processedText);
    }
    this.cleanup();
  }
  insertAtCursor(text) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (activeView == null ? void 0 : activeView.editor) {
      const editor = activeView.editor;
      const cursor = editor.getCursor();
      editor.replaceRange(text, cursor);
      const lines = text.split("\n");
      const lastLineLength = lines[lines.length - 1].length;
      editor.setCursor({
        line: cursor.line + lines.length - 1,
        ch: lines.length === 1 ? cursor.ch + lastLineLength : lastLineLength
      });
      new import_obsidian5.Notice("Transcription inserted");
    } else {
      navigator.clipboard.writeText(text);
      new import_obsidian5.Notice("No active editor. Transcription copied to clipboard.");
    }
  }
  async startAudioCapture() {
    try {
      this.mediaStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          sampleRate: 16e3,
          channelCount: 1,
          echoCancellation: true,
          noiseSuppression: true
        }
      });
      const mimeType = MediaRecorder.isTypeSupported("audio/webm;codecs=opus") ? "audio/webm;codecs=opus" : "audio/webm";
      this.mediaRecorder = new MediaRecorder(this.mediaStream, { mimeType });
      this.audioChunks = [];
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.audioChunks.push(event.data);
        }
      };
      this.mediaRecorder.start(100);
    } catch (error) {
      throw new Error("Failed to access microphone. Please check permissions.");
    }
  }
  async stopAudioCapture() {
    var _a;
    if (this.mediaRecorder && this.mediaRecorder.state !== "inactive") {
      await new Promise((resolve) => {
        this.mediaRecorder.onstop = () => resolve();
        this.mediaRecorder.stop();
      });
    }
    if (this.audioChunks.length > 0) {
      const mimeType = ((_a = this.mediaRecorder) == null ? void 0 : _a.mimeType) || "audio/webm";
      const completeBlob = new Blob(this.audioChunks, { type: mimeType });
      const buffer = await completeBlob.arrayBuffer();
      this.sttService.sendAudioChunk(buffer);
    }
    if (this.mediaStream) {
      this.mediaStream.getTracks().forEach((track) => track.stop());
    }
    this.mediaRecorder = null;
    this.mediaStream = null;
    this.audioChunks = [];
  }
  updateRibbonState(isRecording) {
    if (this.ribbonIcon) {
      if (isRecording) {
        this.ribbonIcon.addClass("stt-recording");
        this.ribbonIcon.setAttribute("aria-label", "Stop Recording");
      } else {
        this.ribbonIcon.removeClass("stt-recording");
        this.ribbonIcon.setAttribute("aria-label", "Start STT Recording");
      }
    }
  }
  cleanup() {
    var _a;
    this.stopVAD();
    if (this.mediaRecorder && this.mediaRecorder.state !== "inactive") {
      this.mediaRecorder.stop();
    }
    if (this.mediaStream) {
      this.mediaStream.getTracks().forEach((track) => track.stop());
    }
    this.mediaRecorder = null;
    this.mediaStream = null;
    this.audioChunks = [];
    (_a = this.modal) == null ? void 0 : _a.close();
    this.modal = null;
    this.state = "idle";
    this.finalTranscript = "";
    this.updateRibbonState(false);
  }
  destroy() {
    this.cleanup();
    this.sttService.disconnect();
  }
};

// src/ui/statusBarManager.ts
var import_obsidian6 = require("obsidian");
var StatusBarManager = class {
  constructor(plugin) {
    this.buttons = /* @__PURE__ */ new Map();
    this.plugin = plugin;
    this.containerEl = plugin.addStatusBarItem();
    this.containerEl.addClass("stt-llm-status-bar-container");
  }
  addButton(id, config) {
    const button = this.containerEl.createEl("span", {
      cls: "stt-llm-status-btn",
      attr: { "aria-label": config.tooltip, "data-tooltip-position": "top" }
    });
    (0, import_obsidian6.setIcon)(button, config.icon);
    button.addEventListener("click", (e) => {
      e.preventDefault();
      config.onClick();
    });
    this.buttons.set(id, button);
    return button;
  }
  setButtonLoading(id, isLoading) {
    const button = this.buttons.get(id);
    if (button) {
      if (isLoading) {
        button.addClass("stt-llm-loading");
      } else {
        button.removeClass("stt-llm-loading");
      }
    }
  }
  hasButton(id) {
    return this.buttons.has(id);
  }
  removeButton(id) {
    const button = this.buttons.get(id);
    if (button) {
      button.remove();
      this.buttons.delete(id);
    }
  }
};

// src/ui/llmSidebarView.ts
var import_obsidian7 = require("obsidian");
var LLM_VIEW_TYPE = "stt-llm-sidebar";
var LlmSidebarView = class extends import_obsidian7.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return LLM_VIEW_TYPE;
  }
  getDisplayText() {
    return "LLM Assistant";
  }
  getIcon() {
    return "bot";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("stt-llm-sidebar");
    const header = container.createEl("div", { cls: "stt-llm-sidebar-header" });
    header.createEl("h3", { text: "LLM Assistant" });
    const actionsSection = container.createEl("div", { cls: "stt-llm-sidebar-section" });
    actionsSection.createEl("h4", { text: "Quick Actions" });
    const actionsContainer = actionsSection.createEl("div", { cls: "stt-llm-actions" });
    this.renderActionButtons(actionsContainer);
    container.createEl("hr", { cls: "stt-llm-divider" });
    const settingsSection = container.createEl("div", { cls: "stt-llm-sidebar-section" });
    settingsSection.createEl("h4", { text: "Settings" });
    const settingsLink = settingsSection.createEl("button", {
      cls: "stt-llm-settings-link"
    });
    const iconSpan = settingsLink.createSpan({ cls: "stt-llm-btn-icon" });
    (0, import_obsidian7.setIcon)(iconSpan, "settings");
    settingsLink.createSpan({ text: "Open LLM Settings" });
    settingsLink.addEventListener("click", () => {
      this.app.setting.open();
      this.app.setting.openTabById(this.plugin.manifest.id);
    });
    const modelInfo = settingsSection.createEl("div", { cls: "stt-llm-model-info" });
    modelInfo.createEl("span", {
      text: `Model: ${this.plugin.settings.llm.model}`,
      cls: "stt-llm-model-label"
    });
  }
  renderActionButtons(container) {
    const actions = [
      {
        id: "summarize",
        label: "Summarize Selection",
        icon: "file-text",
        description: "Summarize selected text"
      },
      {
        id: "custom-prompt",
        label: "Custom Prompt",
        icon: "message-square",
        description: "Send selection with custom prompt"
      },
      {
        id: "auto-tag",
        label: "Generate Tags",
        icon: "tags",
        description: "Auto-generate tags for note"
      },
      {
        id: "toggle-recording",
        label: "Voice Input",
        icon: "mic",
        description: "Start speech-to-text"
      }
    ];
    for (const action of actions) {
      const btn = container.createEl("button", {
        cls: "stt-llm-action-btn",
        attr: { "data-action": action.id }
      });
      const iconSpan = btn.createSpan({ cls: "stt-llm-action-icon" });
      (0, import_obsidian7.setIcon)(iconSpan, action.icon);
      const textContainer = btn.createEl("div", { cls: "stt-llm-action-text" });
      textContainer.createEl("span", { text: action.label, cls: "stt-llm-action-label" });
      textContainer.createEl("span", { text: action.description, cls: "stt-llm-action-desc" });
      btn.addEventListener("click", async () => {
        await this.executeAction(action.id);
      });
    }
  }
  async executeAction(actionId) {
    if (actionId === "summarize" || actionId === "custom-prompt") {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
      if (!(view == null ? void 0 : view.editor)) {
        new import_obsidian7.Notice("No active editor");
        return;
      }
    }
    const commandId = `stt-llm:${actionId}`;
    this.app.commands.executeCommandById(commandId);
  }
  async onClose() {
  }
};

// src/main.ts
var SttLlmPlugin = class extends import_obsidian9.Plugin {
  constructor() {
    super(...arguments);
    this.llmRibbonIcon = null;
  }
  async onload() {
    await this.loadSettings();
    this.llmService = new LlmService(() => this.settings.llm);
    this.tagService = new TagService(this.app);
    this.sttService = new SttService(this.settings.stt.serverUrl);
    this.recordingManager = new RecordingManager(
      this.app,
      this.sttService,
      this.llmService,
      () => this.settings
    );
    this.registerCommands();
    this.registerContextMenu();
    const ribbonIcon = this.addRibbonIcon("mic", "Start STT Recording", async () => {
      await this.recordingManager.toggleRecording();
    });
    this.recordingManager.setRibbonIcon(ribbonIcon);
    this.addSettingTab(new SttLlmSettingTab(this.app, this));
    this.registerView(LLM_VIEW_TYPE, (leaf) => new LlmSidebarView(leaf, this));
    this.statusBarManager = new StatusBarManager(this);
    this.setupLlmUI();
  }
  onunload() {
    var _a;
    (_a = this.recordingManager) == null ? void 0 : _a.destroy();
    this.app.workspace.detachLeavesOfType(LLM_VIEW_TYPE);
  }
  async activateSidebarView() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(LLM_VIEW_TYPE);
    if (leaves.length > 0) {
      leaves.forEach((leaf) => leaf.detach());
    } else {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        await rightLeaf.setViewState({
          type: LLM_VIEW_TYPE,
          active: true
        });
        workspace.revealLeaf(rightLeaf);
      }
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.setupLlmUI();
  }
  /**
   * Setup LLM-related UI elements.
   * Called on load and when settings change.
   * Shows/hides LLM features based on whether LLM is configured.
   */
  setupLlmUI() {
    const llmEnabled = isLlmConfigured(this.settings);
    if (llmEnabled && !this.llmRibbonIcon) {
      this.llmRibbonIcon = this.addRibbonIcon("bot", "Open LLM Assistant", async () => {
        await this.activateSidebarView();
      });
    } else if (!llmEnabled && this.llmRibbonIcon) {
      this.llmRibbonIcon.remove();
      this.llmRibbonIcon = null;
    }
    if (llmEnabled) {
      if (!this.statusBarManager.hasButton("summarize")) {
        this.statusBarManager.addButton("summarize", {
          icon: "file-text",
          tooltip: "Summarize Selection",
          onClick: async () => {
            const view = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
            if (view == null ? void 0 : view.editor) {
              await this.summarizeSelection(view.editor);
            } else {
              new import_obsidian9.Notice("No active editor");
            }
          }
        });
      }
      if (!this.statusBarManager.hasButton("custom-prompt")) {
        this.statusBarManager.addButton("custom-prompt", {
          icon: "message-square",
          tooltip: "Custom Prompt",
          onClick: async () => {
            const view = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
            if (view == null ? void 0 : view.editor) {
              await this.customPrompt(view.editor);
            } else {
              new import_obsidian9.Notice("No active editor");
            }
          }
        });
      }
      if (!this.statusBarManager.hasButton("auto-tag")) {
        this.statusBarManager.addButton("auto-tag", {
          icon: "tags",
          tooltip: "Generate Tags",
          onClick: async () => {
            await this.autoTagCurrentNote();
          }
        });
      }
    } else {
      this.statusBarManager.removeButton("summarize");
      this.statusBarManager.removeButton("custom-prompt");
      this.statusBarManager.removeButton("auto-tag");
    }
  }
  registerCommands() {
    this.addCommand({
      id: "summarize",
      name: "Summarize selection",
      editorCallback: async (editor, view) => {
        await this.summarizeSelection(editor);
      }
    });
    this.addCommand({
      id: "custom-prompt",
      name: "Send selection with custom prompt",
      editorCallback: async (editor, view) => {
        await this.customPrompt(editor);
      }
    });
    this.addCommand({
      id: "auto-tag",
      name: "Generate tags for current note",
      callback: async () => {
        await this.autoTagCurrentNote();
      }
    });
    this.addCommand({
      id: "toggle-recording",
      name: "Toggle STT recording",
      callback: async () => {
        await this.recordingManager.toggleRecording();
      }
    });
  }
  registerContextMenu() {
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor) => {
        if (!isLlmConfigured(this.settings)) {
          return;
        }
        const selection = editor.getSelection();
        menu.addSeparator();
        if (selection) {
          menu.addItem((item) => {
            item.setTitle("Summarize Selection").setIcon("file-text").onClick(async () => {
              await this.summarizeSelection(editor);
            });
          });
          menu.addItem((item) => {
            item.setTitle("Send with Custom Prompt").setIcon("message-square").onClick(async () => {
              await this.customPrompt(editor);
            });
          });
        }
        menu.addItem((item) => {
          item.setTitle("Generate Tags for Note").setIcon("tags").onClick(async () => {
            await this.autoTagCurrentNote();
          });
        });
      })
    );
  }
  async summarizeSelection(editor) {
    const selection = editor.getSelection();
    if (!selection) {
      new import_obsidian9.Notice("No text selected");
      return;
    }
    new import_obsidian9.Notice("Summarizing...");
    try {
      const prompt = this.settings.summarization.prompt.replace("{{text}}", selection);
      let summary = await this.llmService.complete(prompt);
      summary = summary.replace(/\*{0,2}Summary:?\*{0,2}\s*/gi, "").trim();
      const cursor = editor.getCursor("to");
      editor.replaceRange("\n\n**Summary:**\n" + summary, cursor);
      new import_obsidian9.Notice("Summary inserted");
    } catch (error) {
      new import_obsidian9.Notice(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async customPrompt(editor) {
    const selection = editor.getSelection();
    if (!selection) {
      new import_obsidian9.Notice("No text selected");
      return;
    }
    const { CustomPromptModal: CustomPromptModal2 } = await Promise.resolve().then(() => (init_customPromptModal(), customPromptModal_exports));
    new CustomPromptModal2(this.app, this.settings.customPrompt.defaultPrompt, async (userPrompt) => {
      if (!userPrompt)
        return;
      new import_obsidian9.Notice("Processing...");
      try {
        const fullPrompt = `${userPrompt}

Text:
${selection}`;
        const result = await this.llmService.complete(fullPrompt);
        const cursor = editor.getCursor("to");
        editor.replaceRange("\n\n" + result, cursor);
        new import_obsidian9.Notice("Response inserted");
      } catch (error) {
        new import_obsidian9.Notice(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }).open();
  }
  async autoTagCurrentNote() {
    var _a;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian9.Notice("No active note");
      return;
    }
    new import_obsidian9.Notice("Generating tags...");
    try {
      let content = await this.app.vault.read(activeFile);
      content = content.replace(/^---\n[\s\S]*?\n---\n?/, "").trim();
      const cache = this.app.metadataCache.getFileCache(activeFile);
      const existingNoteTags = ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.tags) ? Array.isArray(cache.frontmatter.tags) ? cache.frontmatter.tags : [cache.frontmatter.tags] : [];
      let existingVaultTags = [];
      if (this.settings.tagging.preferExistingTags) {
        existingVaultTags = this.tagService.getAllVaultTags();
      }
      let prompt = this.settings.tagging.prompt;
      prompt = prompt.replace("{{content}}", content);
      if (existingNoteTags.length > 0) {
        prompt += `

This note already has these tags (do NOT suggest these): ${existingNoteTags.join(", ")}`;
      }
      if (existingVaultTags.length > 0) {
        prompt = prompt.replace("{{#if existingTags}}", "");
        prompt = prompt.replace("{{/if}}", "");
        prompt = prompt.replace("{{existingTags}}", existingVaultTags.slice(0, 50).join(", "));
      } else {
        prompt = prompt.replace(/\{\{#if existingTags\}\}[\s\S]*?\{\{\/if\}\}/g, "");
      }
      const response = await this.llmService.complete(prompt);
      let tags;
      try {
        tags = JSON.parse(response.trim());
        if (!Array.isArray(tags)) {
          throw new Error("Response is not an array");
        }
      } catch (e) {
        const match = response.match(/\[[\s\S]*?\]/);
        if (match) {
          tags = JSON.parse(match[0]);
        } else {
          throw new Error("Could not parse tags from response");
        }
      }
      tags = tags.slice(0, this.settings.tagging.maxNewTags);
      tags = tags.map((tag) => tag.startsWith("#") ? tag.slice(1) : tag);
      let newTags = [];
      await this.app.fileManager.processFrontMatter(activeFile, (frontmatter) => {
        const existingFileTags = Array.isArray(frontmatter.tags) ? frontmatter.tags : frontmatter.tags ? [frontmatter.tags] : [];
        const existingSet = new Set(existingFileTags.map((t) => t.toLowerCase()));
        newTags = tags.filter((t) => !existingSet.has(t.toLowerCase()));
        if (newTags.length > 0) {
          frontmatter.tags = [...existingFileTags, ...newTags];
        }
      });
      if (newTags.length > 0) {
        new import_obsidian9.Notice(`Added ${newTags.length} new tag(s): ${newTags.join(", ")}`);
      } else {
        new import_obsidian9.Notice("No new tags to add (all suggested tags already exist)");
      }
    } catch (error) {
      new import_obsidian9.Notice(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
};
