/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/ui/customPromptModal.ts
var customPromptModal_exports = {};
__export(customPromptModal_exports, {
  CustomPromptModal: () => CustomPromptModal
});
var import_obsidian8, CustomPromptModal;
var init_customPromptModal = __esm({
  "src/ui/customPromptModal.ts"() {
    import_obsidian8 = require("obsidian");
    CustomPromptModal = class extends import_obsidian8.Modal {
      constructor(app, defaultPrompt, onSubmit) {
        super(app);
        this.prompt = defaultPrompt;
        this.onSubmit = onSubmit;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("stt-prompt-modal");
        contentEl.createEl("h2", { text: "Custom Prompt" });
        contentEl.createEl("p", {
          text: "Enter your prompt. The selected text will be appended.",
          cls: "setting-item-description"
        });
        const textArea = contentEl.createEl("textarea", {
          cls: "stt-prompt-textarea"
        });
        textArea.value = this.prompt;
        textArea.placeholder = "Enter your prompt here...";
        textArea.rows = 6;
        textArea.style.width = "100%";
        textArea.style.marginBottom = "15px";
        textArea.style.fontFamily = "var(--font-text)";
        textArea.style.padding = "10px";
        textArea.style.borderRadius = "4px";
        textArea.style.border = "1px solid var(--background-modifier-border)";
        textArea.style.backgroundColor = "var(--background-primary)";
        textArea.style.color = "var(--text-normal)";
        textArea.style.resize = "vertical";
        textArea.addEventListener("input", (e) => {
          this.prompt = e.target.value;
        });
        setTimeout(() => textArea.focus(), 10);
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
        buttonContainer.style.display = "flex";
        buttonContainer.style.justifyContent = "flex-end";
        buttonContainer.style.gap = "10px";
        const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
        cancelBtn.addEventListener("click", () => {
          this.onSubmit(null);
          this.close();
        });
        const submitBtn = buttonContainer.createEl("button", {
          text: "Send",
          cls: "mod-cta"
        });
        submitBtn.addEventListener("click", () => {
          this.onSubmit(this.prompt);
          this.close();
        });
        textArea.addEventListener("keydown", (e) => {
          if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            this.onSubmit(this.prompt);
            this.close();
          }
          if (e.key === "Escape") {
            e.preventDefault();
            this.onSubmit(null);
            this.close();
          }
        });
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SttLlmPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian9 = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  stt: {
    serverUrl: "ws://localhost:8765",
    language: "en"
  },
  vad: {
    enabled: true,
    silenceThreshold: 15,
    // 0-100 scale
    silenceDuration: 1.5
    // seconds
  },
  correction: {
    enabled: false,
    prompt: `Fix any transcription errors in the following text. Correct grammar, punctuation, and obvious word mistakes. Keep the original meaning and style. Only output the corrected text, nothing else.

Text: {{text}}`
  },
  llm: {
    baseUrl: "http://localhost:11434",
    apiKey: "",
    model: "llama3.2",
    temperature: 0.7,
    maxTokens: 2048
  },
  summarization: {
    prompt: `Provide a single, concise summary of the following text. Focus on the key points and main ideas. Output ONLY the summary paragraph(s) - no headers, labels, or multiple versions.

Text:
{{text}}`
  },
  tagging: {
    preferExistingTags: true,
    maxNewTags: 5,
    prompt: `Analyze the following content and suggest relevant tags for organizing this note.

{{#if existingTags}}
Prefer tags from this existing list when appropriate: {{existingTags}}
You may also suggest new tags if none of the existing ones fit well.
{{/if}}

Content:
{{content}}

Return ONLY a JSON array of tag strings (without # prefix), e.g., ["tag1", "tag2"]. No other text.`
  },
  customPrompt: {
    defaultPrompt: ""
  }
};

// src/settingsTab.ts
var import_obsidian = require("obsidian");
var SttLlmSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "LLM Settings" });
    new import_obsidian.Setting(containerEl).setName("API Base URL").setDesc("Base URL for OpenAI-compatible API (e.g., Ollama, LM Studio)").addText(
      (text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.llm.baseUrl).onChange(async (value) => {
        this.plugin.settings.llm.baseUrl = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("Optional API key (leave empty for local servers)").addText(
      (text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.llm.apiKey).onChange(async (value) => {
        this.plugin.settings.llm.apiKey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Model").setDesc("Model name to use for completions").addText(
      (text) => text.setPlaceholder("llama3.2").setValue(this.plugin.settings.llm.model).onChange(async (value) => {
        this.plugin.settings.llm.model = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Temperature").setDesc("Controls randomness (0.0 = deterministic, 1.0 = creative)").addSlider(
      (slider) => slider.setLimits(0, 1, 0.1).setValue(this.plugin.settings.llm.temperature).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.llm.temperature = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Max Tokens").setDesc("Maximum tokens in response").addText(
      (text) => text.setPlaceholder("2048").setValue(String(this.plugin.settings.llm.maxTokens)).onChange(async (value) => {
        const parsed = parseInt(value, 10);
        if (!isNaN(parsed) && parsed > 0) {
          this.plugin.settings.llm.maxTokens = parsed;
          await this.plugin.saveSettings();
        }
      })
    );
    containerEl.createEl("h2", { text: "Speech-to-Text Settings" });
    new import_obsidian.Setting(containerEl).setName("STT Server URL").setDesc("WebSocket URL for the STT server").addText(
      (text) => text.setPlaceholder("ws://localhost:8765").setValue(this.plugin.settings.stt.serverUrl).onChange(async (value) => {
        this.plugin.settings.stt.serverUrl = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Language").setDesc("Language code for transcription").addText(
      (text) => text.setPlaceholder("en").setValue(this.plugin.settings.stt.language).onChange(async (value) => {
        this.plugin.settings.stt.language = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Voice Activity Detection" });
    new import_obsidian.Setting(containerEl).setName("Enable Auto-Stop").setDesc("Automatically stop recording after silence is detected").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.vad.enabled).onChange(async (value) => {
        this.plugin.settings.vad.enabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Silence Threshold").setDesc("Audio level below this is considered silence (0-100)").addSlider(
      (slider) => slider.setLimits(5, 50, 5).setValue(this.plugin.settings.vad.silenceThreshold).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.vad.silenceThreshold = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Silence Duration").setDesc("Seconds of silence before auto-stop").addSlider(
      (slider) => slider.setLimits(0.5, 5, 0.5).setValue(this.plugin.settings.vad.silenceDuration).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.vad.silenceDuration = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Transcription Correction" });
    new import_obsidian.Setting(containerEl).setName("Enable LLM Correction").setDesc("Post-process transcriptions with LLM to fix errors").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.correction.enabled).onChange(async (value) => {
        this.plugin.settings.correction.enabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Correction Prompt").setDesc("Prompt template for correction. Use {{text}} for the transcription.").addTextArea(
      (text) => text.setPlaceholder("Fix transcription errors...").setValue(this.plugin.settings.correction.prompt).onChange(async (value) => {
        this.plugin.settings.correction.prompt = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Summarization" });
    new import_obsidian.Setting(containerEl).setName("Summarization Prompt").setDesc("Prompt template for summarization. Use {{text}} for selected text.").addTextArea(
      (text) => text.setPlaceholder("Summarize the following...").setValue(this.plugin.settings.summarization.prompt).onChange(async (value) => {
        this.plugin.settings.summarization.prompt = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Auto-Tagging" });
    new import_obsidian.Setting(containerEl).setName("Prefer Existing Tags").setDesc("Prioritize tags already used in your vault").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.tagging.preferExistingTags).onChange(async (value) => {
        this.plugin.settings.tagging.preferExistingTags = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Max New Tags").setDesc("Maximum number of new tags to generate").addSlider(
      (slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.tagging.maxNewTags).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.tagging.maxNewTags = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Tagging Prompt").setDesc("Prompt template for tag generation. Use {{content}} and {{existingTags}}.").addTextArea(
      (text) => text.setPlaceholder("Analyze and suggest tags...").setValue(this.plugin.settings.tagging.prompt).onChange(async (value) => {
        this.plugin.settings.tagging.prompt = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Custom Prompt" });
    new import_obsidian.Setting(containerEl).setName("Default Custom Prompt").setDesc("Default prompt to show in custom prompt modal (optional)").addTextArea(
      (text) => text.setPlaceholder("Enter your default prompt...").setValue(this.plugin.settings.customPrompt.defaultPrompt).onChange(async (value) => {
        this.plugin.settings.customPrompt.defaultPrompt = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/services/llmService.ts
var import_obsidian2 = require("obsidian");
var LlmService = class {
  constructor(getSettings) {
    this.getSettings = getSettings;
  }
  async complete(userPrompt, systemPrompt) {
    const settings = this.getSettings();
    const messages = [];
    if (systemPrompt) {
      messages.push({ role: "system", content: systemPrompt });
    }
    messages.push({ role: "user", content: userPrompt });
    const isOllama = settings.baseUrl.includes("11434");
    const endpoint = isOllama ? `${settings.baseUrl}/v1/chat/completions` : `${settings.baseUrl}/v1/chat/completions`;
    const headers = {
      "Content-Type": "application/json"
    };
    if (settings.apiKey) {
      headers["Authorization"] = `Bearer ${settings.apiKey}`;
    }
    const body = {
      model: settings.model,
      messages,
      temperature: settings.temperature,
      max_tokens: settings.maxTokens
    };
    try {
      const response = await (0, import_obsidian2.requestUrl)({
        url: endpoint,
        method: "POST",
        headers,
        body: JSON.stringify(body),
        throw: false
      });
      if (response.status !== 200) {
        const errorText = response.text || `HTTP ${response.status}`;
        throw new Error(`LLM request failed: ${errorText}`);
      }
      const data = response.json;
      if (!data.choices || data.choices.length === 0) {
        throw new Error("No response from LLM");
      }
      return data.choices[0].message.content;
    } catch (error) {
      if (error instanceof Error) {
        if (error.message.includes("ECONNREFUSED")) {
          throw new Error(
            `Cannot connect to LLM server at ${settings.baseUrl}. Is the server running?`
          );
        }
        throw error;
      }
      throw new Error("Unknown error occurred");
    }
  }
  async correctTranscription(rawText, correctionPrompt) {
    const prompt = correctionPrompt.replace("{{text}}", rawText);
    return this.complete(prompt);
  }
};

// src/services/tagService.ts
var import_obsidian3 = require("obsidian");
var TagService = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Get all unique tags used across the vault
   */
  getAllVaultTags() {
    const tagSet = /* @__PURE__ */ new Set();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (cache) {
        const tags = (0, import_obsidian3.getAllTags)(cache);
        if (tags) {
          for (const tag of tags) {
            tagSet.add(tag.startsWith("#") ? tag.slice(1) : tag);
          }
        }
      }
    }
    return Array.from(tagSet).sort();
  }
  /**
   * Get tags that match a partial string (for autocomplete)
   */
  searchTags(query) {
    const allTags = this.getAllVaultTags();
    const lowerQuery = query.toLowerCase();
    return allTags.filter((tag) => tag.toLowerCase().includes(lowerQuery));
  }
  /**
   * Get the most commonly used tags
   */
  getPopularTags(limit = 20) {
    const tagCounts = /* @__PURE__ */ new Map();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (cache) {
        const tags = (0, import_obsidian3.getAllTags)(cache);
        if (tags) {
          for (const tag of tags) {
            const normalizedTag = tag.startsWith("#") ? tag.slice(1) : tag;
            tagCounts.set(normalizedTag, (tagCounts.get(normalizedTag) || 0) + 1);
          }
        }
      }
    }
    return Array.from(tagCounts.entries()).sort((a, b) => b[1] - a[1]).slice(0, limit).map(([tag]) => tag);
  }
};

// src/services/sttService.ts
var SttService = class {
  constructor(url) {
    this.ws = null;
    this.listeners = {};
    this._status = "disconnected";
    this.connectionId = 0;
    this.url = url;
  }
  get status() {
    return this._status;
  }
  get isConnected() {
    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;
  }
  get isRecording() {
    return this._status === "recording";
  }
  setUrl(url) {
    this.url = url;
  }
  on(event, callback) {
    this.listeners[event] = callback;
  }
  off(event) {
    delete this.listeners[event];
  }
  emit(event, ...args) {
    const callback = this.listeners[event];
    if (callback) {
      callback(...args);
    }
  }
  setStatus(status, error) {
    this._status = status;
    this.emit("status", { status, error });
  }
  async connect() {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      return;
    }
    if (this.ws) {
      this.ws.onclose = null;
      this.ws.onerror = null;
      this.ws.onmessage = null;
      this.ws.onopen = null;
      try {
        this.ws.close();
      } catch (e) {
      }
      this.ws = null;
    }
    this.setStatus("connecting");
    this.connectionId++;
    const thisConnectionId = this.connectionId;
    return new Promise((resolve, reject) => {
      let resolved = false;
      let timeoutId = null;
      const cleanup = () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
      };
      try {
        const ws = new WebSocket(this.url);
        timeoutId = setTimeout(() => {
          if (!resolved && thisConnectionId === this.connectionId) {
            resolved = true;
            ws.close();
            if (this.ws === ws)
              this.ws = null;
            reject(new Error("Connection timeout"));
          }
        }, 1e4);
        ws.onopen = () => {
          if (thisConnectionId !== this.connectionId) {
            ws.close();
            return;
          }
          if (!resolved) {
            resolved = true;
            cleanup();
            this.ws = ws;
            this.emit("connected");
            resolve();
          }
        };
        ws.onclose = (event) => {
          cleanup();
          if (thisConnectionId !== this.connectionId) {
            return;
          }
          if (this.ws === ws)
            this.ws = null;
          this.setStatus("disconnected");
          this.emit("disconnected");
          if (!resolved) {
            resolved = true;
            reject(new Error("Connection closed"));
          }
        };
        ws.onerror = (error) => {
          cleanup();
          if (thisConnectionId !== this.connectionId) {
            return;
          }
          console.error("STT WebSocket error:", error);
          if (!resolved) {
            resolved = true;
            this.setStatus("error", "Connection error");
            reject(new Error("WebSocket connection failed"));
          }
        };
        ws.onmessage = (event) => {
          if (thisConnectionId !== this.connectionId) {
            return;
          }
          this.handleMessage(event.data);
        };
      } catch (error) {
        cleanup();
        this.setStatus("error", "Failed to create WebSocket");
        reject(error);
      }
    });
  }
  disconnect() {
    this.connectionId++;
    if (this.ws) {
      this.ws.onclose = null;
      this.ws.onerror = null;
      this.ws.onmessage = null;
      this.ws.onopen = null;
      try {
        this.ws.close(1e3, "Client disconnect");
      } catch (e) {
      }
      this.ws = null;
    }
    this.setStatus("disconnected");
  }
  startRecording(language) {
    var _a;
    if (!this.isConnected) {
      throw new Error("Not connected to STT server");
    }
    const message = { type: "start" };
    if (language) {
      message.language = language;
    }
    (_a = this.ws) == null ? void 0 : _a.send(JSON.stringify(message));
  }
  stopRecording() {
    var _a;
    if (!this.isConnected) {
      throw new Error("Not connected to STT server");
    }
    (_a = this.ws) == null ? void 0 : _a.send(JSON.stringify({ type: "stop" }));
  }
  sendAudioChunk(audioData) {
    var _a;
    if (!this.isConnected || this._status !== "recording") {
      return;
    }
    const base64 = this.arrayBufferToBase64(audioData);
    (_a = this.ws) == null ? void 0 : _a.send(
      JSON.stringify({
        type: "audio",
        data: base64
      })
    );
  }
  arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = "";
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }
  handleMessage(data) {
    try {
      const message = JSON.parse(data);
      switch (message.type) {
        case "status":
          this.setStatus(message.status, message.error);
          break;
        case "transcript":
          this.emit("transcript", {
            text: message.text,
            isFinal: message.isFinal
          });
          break;
        default:
          console.warn("Unknown STT message type:", message.type);
      }
    } catch (error) {
      console.error("Error parsing STT message:", error);
    }
  }
};

// src/features/recordingManager.ts
var import_obsidian5 = require("obsidian");

// src/ui/recordingModal.ts
var import_obsidian4 = require("obsidian");
var RecordingModal = class extends import_obsidian4.Modal {
  constructor(app, onStop) {
    super(app);
    this.audioLevelEl = null;
    this.audioLevelBar = null;
    this.currentTranscript = "";
    this.onStop = onStop;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("stt-recording-modal");
    this.statusEl = contentEl.createEl("div", {
      cls: "stt-status",
      text: "Connecting..."
    });
    this.indicatorEl = contentEl.createEl("div", { cls: "stt-indicator" });
    this.indicatorEl.createEl("span", { cls: "stt-pulse" });
    this.indicatorEl.style.display = "none";
    this.audioLevelEl = contentEl.createEl("div", { cls: "stt-audio-level" });
    this.audioLevelBar = this.audioLevelEl.createEl("div", { cls: "stt-audio-level-bar" });
    this.audioLevelEl.style.display = "none";
    this.transcriptEl = contentEl.createEl("div", {
      cls: "stt-transcript",
      text: "Waiting for speech..."
    });
    this.stopBtn = contentEl.createEl("button", {
      text: "Stop Recording",
      cls: "stt-stop-btn mod-cta"
    });
    this.stopBtn.addEventListener("click", () => {
      this.onStop();
    });
    this.scope.register([], "Escape", () => {
      this.onStop();
      return false;
    });
  }
  /**
   * Update the status display
   */
  updateStatus(status) {
    if (this.statusEl) {
      this.statusEl.setText(status);
    }
    const isRecording = status.toLowerCase().includes("recording");
    if (this.indicatorEl) {
      this.indicatorEl.style.display = isRecording ? "flex" : "none";
    }
    if (this.audioLevelEl) {
      this.audioLevelEl.style.display = isRecording ? "block" : "none";
    }
  }
  /**
   * Update the audio level display (0-100) and optional silence countdown
   */
  updateAudioLevel(level, silenceCountdown) {
    if (this.audioLevelBar) {
      this.audioLevelBar.style.width = `${Math.min(100, level)}%`;
    }
    if (this.statusEl) {
      if (silenceCountdown !== void 0 && silenceCountdown > 0) {
        this.statusEl.setText(`Recording... (auto-stop in ${silenceCountdown.toFixed(1)}s)`);
      } else if (this.statusEl.getText().includes("auto-stop")) {
        this.statusEl.setText("Recording... Speak now");
      }
    }
  }
  /**
   * Update the transcript display
   */
  updateTranscript(text, isFinal) {
    this.currentTranscript = text;
    if (this.transcriptEl) {
      if (text) {
        this.transcriptEl.setText(text);
        this.transcriptEl.removeClass("stt-final");
        if (isFinal) {
          this.transcriptEl.addClass("stt-final");
        }
      } else {
        this.transcriptEl.setText("Waiting for speech...");
      }
    }
  }
  /**
   * Get the current transcript
   */
  getTranscript() {
    return this.currentTranscript;
  }
  /**
   * Show error state
   */
  showError(message) {
    this.updateStatus(`Error: ${message}`);
    if (this.indicatorEl) {
      this.indicatorEl.style.display = "none";
    }
    if (this.stopBtn) {
      this.stopBtn.setText("Close");
    }
  }
  /**
   * Show processing state
   */
  showProcessing() {
    this.updateStatus("Processing final transcript...");
    if (this.indicatorEl) {
      this.indicatorEl.style.display = "none";
    }
    if (this.stopBtn) {
      this.stopBtn.disabled = true;
      this.stopBtn.setText("Processing...");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/features/recordingManager.ts
var RecordingManager = class {
  constructor(app, sttService, llmService, getSettings) {
    this.state = "idle";
    this.modal = null;
    this.mediaRecorder = null;
    this.mediaStream = null;
    this.audioChunks = [];
    this.finalTranscript = "";
    this.ribbonIcon = null;
    // VAD (Voice Activity Detection)
    this.audioContext = null;
    this.analyser = null;
    this.vadInterval = null;
    this.silenceStart = null;
    this.app = app;
    this.sttService = sttService;
    this.llmService = llmService;
    this.getSettings = getSettings;
    this.setupSttCallbacks();
  }
  setRibbonIcon(icon) {
    this.ribbonIcon = icon;
  }
  isRecording() {
    return this.state === "recording";
  }
  setupSttCallbacks() {
    this.sttService.on("status", ({ status, error }) => {
      var _a, _b, _c;
      if (status === "recording") {
        this.state = "recording";
        (_a = this.modal) == null ? void 0 : _a.updateStatus("Recording... Speak now");
        this.updateRibbonState(true);
        this.startVAD();
      } else if (status === "processing") {
        this.state = "processing";
        (_b = this.modal) == null ? void 0 : _b.showProcessing();
      } else if (status === "ready") {
        if (this.state === "processing") {
          this.handleRecordingComplete();
        }
      } else if (status === "error") {
        console.error("STT error:", error);
        (_c = this.modal) == null ? void 0 : _c.showError(error || "Unknown error");
        this.cleanup();
      }
    });
    this.sttService.on("transcript", ({ text, isFinal }) => {
      var _a;
      (_a = this.modal) == null ? void 0 : _a.updateTranscript(text, isFinal);
      if (isFinal) {
        this.finalTranscript = text;
      }
    });
    this.sttService.on("disconnected", () => {
      if (this.state !== "idle") {
        new import_obsidian5.Notice("STT server disconnected");
        this.cleanup();
      }
    });
  }
  async toggleRecording() {
    if (this.state === "idle") {
      await this.startRecording();
    } else if (this.state === "recording") {
      await this.stopRecording();
    }
  }
  async startRecording() {
    var _a;
    if (this.state !== "idle") {
      return;
    }
    const settings = this.getSettings();
    this.sttService.setUrl(settings.stt.serverUrl);
    this.modal = new RecordingModal(this.app, () => this.stopRecording());
    this.modal.open();
    this.modal.updateStatus("Connecting to STT server...");
    this.state = "connecting";
    try {
      await this.sttService.connect();
      await this.startAudioCapture();
      this.sttService.startRecording(settings.stt.language);
      this.finalTranscript = "";
    } catch (error) {
      console.error("Error starting recording:", error);
      const message = error instanceof Error ? error.message : "Unknown error";
      (_a = this.modal) == null ? void 0 : _a.showError(message);
      new import_obsidian5.Notice(`Failed to start recording: ${message}`);
      this.cleanup();
    }
  }
  async stopRecording() {
    var _a;
    if (this.state !== "recording") {
      if (this.state === "connecting" || this.state === "processing") {
        this.cleanup();
      }
      return;
    }
    this.state = "processing";
    (_a = this.modal) == null ? void 0 : _a.showProcessing();
    this.stopVAD();
    try {
      await this.stopAudioCapture();
      this.sttService.stopRecording();
    } catch (error) {
      console.error("Error stopping recording:", error);
      this.cleanup();
    }
  }
  startVAD() {
    const settings = this.getSettings();
    if (!settings.vad.enabled || !this.mediaStream) {
      return;
    }
    try {
      this.audioContext = new AudioContext();
      const source = this.audioContext.createMediaStreamSource(this.mediaStream);
      this.analyser = this.audioContext.createAnalyser();
      this.analyser.fftSize = 256;
      source.connect(this.analyser);
      const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
      this.silenceStart = null;
      this.vadInterval = setInterval(() => {
        var _a, _b;
        if (!this.analyser || this.state !== "recording") {
          return;
        }
        this.analyser.getByteFrequencyData(dataArray);
        const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
        const level = average / 255 * 100;
        const threshold = settings.vad.silenceThreshold;
        const silenceDurationMs = settings.vad.silenceDuration * 1e3;
        let countdown;
        if (level < threshold) {
          if (this.silenceStart === null) {
            this.silenceStart = Date.now();
          }
          const elapsed = Date.now() - this.silenceStart;
          const remaining = (silenceDurationMs - elapsed) / 1e3;
          countdown = Math.max(0, remaining);
          if (elapsed > silenceDurationMs) {
            this.stopRecording();
            return;
          }
        } else {
          this.silenceStart = null;
        }
        (_b = (_a = this.modal) == null ? void 0 : _a.updateAudioLevel) == null ? void 0 : _b.call(_a, level, countdown);
      }, 100);
    } catch (error) {
      console.error("Error starting VAD:", error);
    }
  }
  stopVAD() {
    if (this.vadInterval) {
      clearInterval(this.vadInterval);
      this.vadInterval = null;
    }
    if (this.audioContext) {
      this.audioContext.close().catch(() => {
      });
      this.audioContext = null;
    }
    this.analyser = null;
    this.silenceStart = null;
  }
  async handleRecordingComplete() {
    var _a, _b;
    let text = this.finalTranscript || ((_a = this.modal) == null ? void 0 : _a.getTranscript()) || "";
    if (!text.trim()) {
      new import_obsidian5.Notice("No speech detected");
      this.cleanup();
      return;
    }
    const settings = this.getSettings();
    if (settings.correction.enabled) {
      try {
        (_b = this.modal) == null ? void 0 : _b.updateStatus("Applying LLM correction...");
        text = await this.llmService.correctTranscription(text, settings.correction.prompt);
      } catch (error) {
        console.error("LLM correction failed:", error);
      }
    }
    this.insertAtCursor(text);
    this.cleanup();
  }
  insertAtCursor(text) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (activeView == null ? void 0 : activeView.editor) {
      const editor = activeView.editor;
      const cursor = editor.getCursor();
      editor.replaceRange(text, cursor);
      const lines = text.split("\n");
      const lastLineLength = lines[lines.length - 1].length;
      editor.setCursor({
        line: cursor.line + lines.length - 1,
        ch: lines.length === 1 ? cursor.ch + lastLineLength : lastLineLength
      });
      new import_obsidian5.Notice("Transcription inserted");
    } else {
      navigator.clipboard.writeText(text);
      new import_obsidian5.Notice("No active editor. Transcription copied to clipboard.");
    }
  }
  async startAudioCapture() {
    try {
      this.mediaStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          sampleRate: 16e3,
          channelCount: 1,
          echoCancellation: true,
          noiseSuppression: true
        }
      });
      const mimeType = MediaRecorder.isTypeSupported("audio/webm;codecs=opus") ? "audio/webm;codecs=opus" : "audio/webm";
      this.mediaRecorder = new MediaRecorder(this.mediaStream, { mimeType });
      this.audioChunks = [];
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.audioChunks.push(event.data);
        }
      };
      this.mediaRecorder.start(100);
    } catch (error) {
      console.error("Error starting audio capture:", error);
      throw new Error("Failed to access microphone. Please check permissions.");
    }
  }
  async stopAudioCapture() {
    var _a;
    if (this.mediaRecorder && this.mediaRecorder.state !== "inactive") {
      await new Promise((resolve) => {
        this.mediaRecorder.onstop = () => resolve();
        this.mediaRecorder.stop();
      });
    }
    if (this.audioChunks.length > 0) {
      const mimeType = ((_a = this.mediaRecorder) == null ? void 0 : _a.mimeType) || "audio/webm";
      const completeBlob = new Blob(this.audioChunks, { type: mimeType });
      const buffer = await completeBlob.arrayBuffer();
      this.sttService.sendAudioChunk(buffer);
    }
    if (this.mediaStream) {
      this.mediaStream.getTracks().forEach((track) => track.stop());
    }
    this.mediaRecorder = null;
    this.mediaStream = null;
    this.audioChunks = [];
  }
  updateRibbonState(isRecording) {
    if (this.ribbonIcon) {
      if (isRecording) {
        this.ribbonIcon.addClass("stt-recording");
        this.ribbonIcon.setAttribute("aria-label", "Stop Recording");
      } else {
        this.ribbonIcon.removeClass("stt-recording");
        this.ribbonIcon.setAttribute("aria-label", "Start STT Recording");
      }
    }
  }
  cleanup() {
    var _a;
    this.stopVAD();
    if (this.mediaRecorder && this.mediaRecorder.state !== "inactive") {
      this.mediaRecorder.stop();
    }
    if (this.mediaStream) {
      this.mediaStream.getTracks().forEach((track) => track.stop());
    }
    this.mediaRecorder = null;
    this.mediaStream = null;
    this.audioChunks = [];
    (_a = this.modal) == null ? void 0 : _a.close();
    this.modal = null;
    this.state = "idle";
    this.finalTranscript = "";
    this.updateRibbonState(false);
  }
  destroy() {
    this.cleanup();
    this.sttService.disconnect();
  }
};

// src/ui/statusBarManager.ts
var import_obsidian6 = require("obsidian");
var StatusBarManager = class {
  constructor(plugin) {
    this.buttons = /* @__PURE__ */ new Map();
    this.plugin = plugin;
    this.containerEl = plugin.addStatusBarItem();
    this.containerEl.addClass("stt-llm-status-bar-container");
  }
  addButton(id, config) {
    const button = this.containerEl.createEl("span", {
      cls: "stt-llm-status-btn",
      attr: { "aria-label": config.tooltip, "data-tooltip-position": "top" }
    });
    (0, import_obsidian6.setIcon)(button, config.icon);
    button.addEventListener("click", (e) => {
      e.preventDefault();
      config.onClick();
    });
    this.buttons.set(id, button);
    return button;
  }
  setButtonLoading(id, isLoading) {
    const button = this.buttons.get(id);
    if (button) {
      if (isLoading) {
        button.addClass("stt-llm-loading");
      } else {
        button.removeClass("stt-llm-loading");
      }
    }
  }
};

// src/ui/llmSidebarView.ts
var import_obsidian7 = require("obsidian");
var LLM_VIEW_TYPE = "stt-llm-sidebar";
var LlmSidebarView = class extends import_obsidian7.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.operationHistory = [];
    this.plugin = plugin;
  }
  getViewType() {
    return LLM_VIEW_TYPE;
  }
  getDisplayText() {
    return "LLM Assistant";
  }
  getIcon() {
    return "bot";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("stt-llm-sidebar");
    const header = container.createEl("div", { cls: "stt-llm-sidebar-header" });
    header.createEl("h3", { text: "LLM Assistant" });
    const actionsSection = container.createEl("div", { cls: "stt-llm-sidebar-section" });
    actionsSection.createEl("h4", { text: "Quick Actions" });
    const actionsContainer = actionsSection.createEl("div", { cls: "stt-llm-actions" });
    this.renderActionButtons(actionsContainer);
    container.createEl("hr", { cls: "stt-llm-divider" });
    const historySection = container.createEl("div", { cls: "stt-llm-sidebar-section" });
    historySection.createEl("h4", { text: "Recent Operations" });
    this.historyContainerEl = historySection.createEl("div", { cls: "stt-llm-history" });
    this.renderHistory();
    container.createEl("hr", { cls: "stt-llm-divider" });
    const settingsSection = container.createEl("div", { cls: "stt-llm-sidebar-section" });
    settingsSection.createEl("h4", { text: "Settings" });
    const settingsLink = settingsSection.createEl("button", {
      cls: "stt-llm-settings-link"
    });
    const iconSpan = settingsLink.createSpan({ cls: "stt-llm-btn-icon" });
    (0, import_obsidian7.setIcon)(iconSpan, "settings");
    settingsLink.createSpan({ text: "Open LLM Settings" });
    settingsLink.addEventListener("click", () => {
      this.app.setting.open();
      this.app.setting.openTabById(this.plugin.manifest.id);
    });
    const modelInfo = settingsSection.createEl("div", { cls: "stt-llm-model-info" });
    modelInfo.createEl("span", {
      text: `Model: ${this.plugin.settings.llm.model}`,
      cls: "stt-llm-model-label"
    });
  }
  renderActionButtons(container) {
    const actions = [
      {
        id: "summarize",
        label: "Summarize Selection",
        icon: "file-text",
        description: "Summarize selected text"
      },
      {
        id: "custom-prompt",
        label: "Custom Prompt",
        icon: "message-square",
        description: "Send selection with custom prompt"
      },
      {
        id: "auto-tag",
        label: "Generate Tags",
        icon: "tags",
        description: "Auto-generate tags for note"
      },
      {
        id: "toggle-recording",
        label: "Voice Input",
        icon: "mic",
        description: "Start speech-to-text"
      }
    ];
    for (const action of actions) {
      const btn = container.createEl("button", {
        cls: "stt-llm-action-btn",
        attr: { "data-action": action.id }
      });
      const iconSpan = btn.createSpan({ cls: "stt-llm-action-icon" });
      (0, import_obsidian7.setIcon)(iconSpan, action.icon);
      const textContainer = btn.createEl("div", { cls: "stt-llm-action-text" });
      textContainer.createEl("span", { text: action.label, cls: "stt-llm-action-label" });
      textContainer.createEl("span", { text: action.description, cls: "stt-llm-action-desc" });
      btn.addEventListener("click", async () => {
        await this.executeAction(action.id);
      });
    }
  }
  async executeAction(actionId) {
    const commandId = `stt-llm:${actionId}`;
    let success = false;
    try {
      this.app.commands.executeCommandById(commandId);
      success = true;
    } catch (error) {
      success = false;
    }
    if (actionId !== "toggle-recording") {
      this.addToHistory({
        type: actionId,
        timestamp: /* @__PURE__ */ new Date(),
        success
      });
    }
  }
  addToHistory(item) {
    this.operationHistory.unshift(item);
    if (this.operationHistory.length > 10) {
      this.operationHistory.pop();
    }
    this.renderHistory();
  }
  renderHistory() {
    if (!this.historyContainerEl)
      return;
    this.historyContainerEl.empty();
    if (this.operationHistory.length === 0) {
      this.historyContainerEl.createEl("div", {
        text: "No recent operations",
        cls: "stt-llm-history-empty"
      });
      return;
    }
    for (const item of this.operationHistory) {
      const historyItem = this.historyContainerEl.createEl("div", {
        cls: `stt-llm-history-item ${item.success ? "success" : "error"}`
      });
      const iconSpan = historyItem.createSpan({ cls: "stt-llm-history-icon" });
      const iconName = item.type === "summarize" ? "file-text" : item.type === "custom-prompt" ? "message-square" : "tags";
      (0, import_obsidian7.setIcon)(iconSpan, iconName);
      const content = historyItem.createEl("div", { cls: "stt-llm-history-content" });
      content.createEl("span", {
        text: this.getActionLabel(item.type),
        cls: "stt-llm-history-label"
      });
      content.createEl("span", {
        text: this.formatTime(item.timestamp),
        cls: "stt-llm-history-time"
      });
    }
  }
  getActionLabel(type) {
    switch (type) {
      case "summarize":
        return "Summarize";
      case "custom-prompt":
        return "Custom Prompt";
      case "auto-tag":
        return "Generate Tags";
      default:
        return type;
    }
  }
  formatTime(date) {
    const now = /* @__PURE__ */ new Date();
    const diff = now.getTime() - date.getTime();
    if (diff < 6e4)
      return "Just now";
    if (diff < 36e5)
      return `${Math.floor(diff / 6e4)}m ago`;
    if (diff < 864e5)
      return `${Math.floor(diff / 36e5)}h ago`;
    return date.toLocaleDateString();
  }
  async onClose() {
  }
};

// src/main.ts
var SttLlmPlugin = class extends import_obsidian9.Plugin {
  async onload() {
    await this.loadSettings();
    this.llmService = new LlmService(() => this.settings.llm);
    this.tagService = new TagService(this.app);
    this.sttService = new SttService(this.settings.stt.serverUrl);
    this.recordingManager = new RecordingManager(
      this.app,
      this.sttService,
      this.llmService,
      () => this.settings
    );
    this.registerCommands();
    this.registerContextMenu();
    const ribbonIcon = this.addRibbonIcon("mic", "Start STT Recording", async () => {
      await this.recordingManager.toggleRecording();
    });
    this.recordingManager.setRibbonIcon(ribbonIcon);
    this.addSettingTab(new SttLlmSettingTab(this.app, this));
    this.registerView(LLM_VIEW_TYPE, (leaf) => new LlmSidebarView(leaf, this));
    this.addRibbonIcon("bot", "Open LLM Assistant", async () => {
      await this.activateSidebarView();
    });
    this.addCommand({
      id: "open-llm-sidebar",
      name: "Open LLM Assistant panel",
      callback: async () => {
        await this.activateSidebarView();
      }
    });
    this.statusBarManager = new StatusBarManager(this);
    this.statusBarManager.addButton("summarize", {
      icon: "file-text",
      tooltip: "Summarize Selection",
      onClick: async () => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
        if (view == null ? void 0 : view.editor) {
          await this.summarizeSelection(view.editor);
        } else {
          new import_obsidian9.Notice("No active editor");
        }
      }
    });
    this.statusBarManager.addButton("custom-prompt", {
      icon: "message-square",
      tooltip: "Custom Prompt",
      onClick: async () => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
        if (view == null ? void 0 : view.editor) {
          await this.customPrompt(view.editor);
        } else {
          new import_obsidian9.Notice("No active editor");
        }
      }
    });
    this.statusBarManager.addButton("auto-tag", {
      icon: "tags",
      tooltip: "Generate Tags",
      onClick: async () => {
        await this.autoTagCurrentNote();
      }
    });
    console.log("STT & LLM plugin loaded");
  }
  onunload() {
    var _a;
    (_a = this.recordingManager) == null ? void 0 : _a.destroy();
    this.app.workspace.detachLeavesOfType(LLM_VIEW_TYPE);
    console.log("STT & LLM plugin unloaded");
  }
  async activateSidebarView() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(LLM_VIEW_TYPE);
    if (leaves.length > 0) {
      leaves.forEach((leaf) => leaf.detach());
    } else {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        await rightLeaf.setViewState({
          type: LLM_VIEW_TYPE,
          active: true
        });
        workspace.revealLeaf(rightLeaf);
      }
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  registerCommands() {
    this.addCommand({
      id: "summarize",
      name: "Summarize selection",
      editorCallback: async (editor, view) => {
        await this.summarizeSelection(editor);
      }
    });
    this.addCommand({
      id: "custom-prompt",
      name: "Send selection with custom prompt",
      editorCallback: async (editor, view) => {
        await this.customPrompt(editor);
      }
    });
    this.addCommand({
      id: "auto-tag",
      name: "Generate tags for current note",
      callback: async () => {
        await this.autoTagCurrentNote();
      }
    });
    this.addCommand({
      id: "toggle-recording",
      name: "Toggle STT recording",
      callback: async () => {
        await this.recordingManager.toggleRecording();
      }
    });
  }
  registerContextMenu() {
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor) => {
        const selection = editor.getSelection();
        menu.addSeparator();
        if (selection) {
          menu.addItem((item) => {
            item.setTitle("Summarize Selection").setIcon("file-text").onClick(async () => {
              await this.summarizeSelection(editor);
            });
          });
          menu.addItem((item) => {
            item.setTitle("Send with Custom Prompt").setIcon("message-square").onClick(async () => {
              await this.customPrompt(editor);
            });
          });
        }
        menu.addItem((item) => {
          item.setTitle("Generate Tags for Note").setIcon("tags").onClick(async () => {
            await this.autoTagCurrentNote();
          });
        });
      })
    );
  }
  async summarizeSelection(editor) {
    const selection = editor.getSelection();
    if (!selection) {
      new import_obsidian9.Notice("No text selected");
      return;
    }
    new import_obsidian9.Notice("Summarizing...");
    try {
      const prompt = this.settings.summarization.prompt.replace("{{text}}", selection);
      let summary = await this.llmService.complete(prompt);
      summary = summary.replace(/\*{0,2}Summary:?\*{0,2}\s*/gi, "").trim();
      const cursor = editor.getCursor("to");
      editor.replaceRange("\n\n**Summary:**\n" + summary, cursor);
      new import_obsidian9.Notice("Summary inserted");
    } catch (error) {
      console.error("Summarization error:", error);
      new import_obsidian9.Notice(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async customPrompt(editor) {
    const selection = editor.getSelection();
    if (!selection) {
      new import_obsidian9.Notice("No text selected");
      return;
    }
    const { CustomPromptModal: CustomPromptModal2 } = await Promise.resolve().then(() => (init_customPromptModal(), customPromptModal_exports));
    new CustomPromptModal2(this.app, this.settings.customPrompt.defaultPrompt, async (userPrompt) => {
      if (!userPrompt)
        return;
      new import_obsidian9.Notice("Processing...");
      try {
        const fullPrompt = `${userPrompt}

Text:
${selection}`;
        const result = await this.llmService.complete(fullPrompt);
        const cursor = editor.getCursor("to");
        editor.replaceRange("\n\n" + result, cursor);
        new import_obsidian9.Notice("Response inserted");
      } catch (error) {
        console.error("Custom prompt error:", error);
        new import_obsidian9.Notice(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }).open();
  }
  async autoTagCurrentNote() {
    var _a;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian9.Notice("No active note");
      return;
    }
    new import_obsidian9.Notice("Generating tags...");
    try {
      let content = await this.app.vault.read(activeFile);
      content = content.replace(/^---\n[\s\S]*?\n---\n?/, "").trim();
      const cache = this.app.metadataCache.getFileCache(activeFile);
      const existingNoteTags = ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.tags) ? Array.isArray(cache.frontmatter.tags) ? cache.frontmatter.tags : [cache.frontmatter.tags] : [];
      let existingVaultTags = [];
      if (this.settings.tagging.preferExistingTags) {
        existingVaultTags = this.tagService.getAllVaultTags();
      }
      let prompt = this.settings.tagging.prompt;
      prompt = prompt.replace("{{content}}", content);
      if (existingNoteTags.length > 0) {
        prompt += `

This note already has these tags (do NOT suggest these): ${existingNoteTags.join(", ")}`;
      }
      if (existingVaultTags.length > 0) {
        prompt = prompt.replace("{{#if existingTags}}", "");
        prompt = prompt.replace("{{/if}}", "");
        prompt = prompt.replace("{{existingTags}}", existingVaultTags.slice(0, 50).join(", "));
      } else {
        prompt = prompt.replace(/\{\{#if existingTags\}\}[\s\S]*?\{\{\/if\}\}/g, "");
      }
      const response = await this.llmService.complete(prompt);
      let tags;
      try {
        tags = JSON.parse(response.trim());
        if (!Array.isArray(tags)) {
          throw new Error("Response is not an array");
        }
      } catch (e) {
        const match = response.match(/\[[\s\S]*?\]/);
        if (match) {
          tags = JSON.parse(match[0]);
        } else {
          throw new Error("Could not parse tags from response");
        }
      }
      tags = tags.slice(0, this.settings.tagging.maxNewTags);
      tags = tags.map((tag) => tag.startsWith("#") ? tag.slice(1) : tag);
      let newTags = [];
      await this.app.fileManager.processFrontMatter(activeFile, (frontmatter) => {
        const existingFileTags = Array.isArray(frontmatter.tags) ? frontmatter.tags : frontmatter.tags ? [frontmatter.tags] : [];
        const existingSet = new Set(existingFileTags.map((t) => t.toLowerCase()));
        newTags = tags.filter((t) => !existingSet.has(t.toLowerCase()));
        if (newTags.length > 0) {
          frontmatter.tags = [...existingFileTags, ...newTags];
        }
      });
      if (newTags.length > 0) {
        new import_obsidian9.Notice(`Added ${newTags.length} new tag(s): ${newTags.join(", ")}`);
      } else {
        new import_obsidian9.Notice("No new tags to add (all suggested tags already exist)");
      }
    } catch (error) {
      console.error("Auto-tag error:", error);
      new import_obsidian9.Notice(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
};
